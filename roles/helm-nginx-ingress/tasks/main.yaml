---
################################
# Install Nginx-Ingress via Helm
################################

- name: Creating ConfigMap for the controller
  tempfile:
    state: file
    suffix: temp
  register: tempfile

- name: "Create config map for nginx-ingress-{{ k8s_namespace }}-controller"
  template:
    src: configmap.yaml.j2
    dest: "{{ tempfile.path }}"
  
- name: Apply config to cluster
  shell: >
    cat {{ tempfile.path }} | kubectl create -f -
  ignore_errors: true
  args:
    executable: /bin/bash

- name: Delete temp file
  file:
    path: "{{ tempfile.path }}"
    state: absent

- name: "Checking SSL for *.{{ dns_zone }}"
  aws_acm_facts:
    domain_name: "*.{{ dns_zone }}"
    region: "{{ aws_region }}"
    statuses: ISSUED
  register: acm

- name: Extract Certificate ARN
  set_fact:
    certificate_arn: "{{ acm.certificates[0].certificate_arn }}"
  
- debug:
    var: certificate_arn

- name: "Adding Nginx-Ingress via Helm"
  shell: >-
    helm install --atomic --dep-up
    --name nginx-ingress-{{ k8s_namespace }}
    --namespace {{ k8s_namespace }}
    --set controller.service.targetPorts.https=80
    --set controller.metrics.enabled=true
    --set controller.ingressClass="{{ k8s_namespace }}-nginx"
    --set defaultBackend.name="{{ k8s_namespace }}-default-backend"
    --set controller.service.annotations."{{ "service.beta.kubernetes.io/aws-load-balancer-type" | regex_escape() }}={{ elb_type }}"
    --set controller.service.annotations."{{ "service.beta.kubernetes.io/aws-load-balancer-ssl-ports" | regex_escape() }}=https"
    --set controller.service.annotations."{{ "service.beta.kubernetes.io/aws-load-balancer-ssl-cert" | regex_escape() }}={{ certificate_arn | regex_escape() }}"
    --set controller.service.annotations."{{ "service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled" | regex_escape() }}=true"
    stable/nginx-ingress
  args:
    executable: /bin/bash

- name: Wait for the Controller to be deployed.
  shell: >
    kubectl get svc nginx-ingress-{{ k8s_namespace }}-controller -n {{ k8s_namespace }} -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"
  args:
    executable: /bin/bash
  ignore_errors: true
  register: cmd_result
  until: cmd_result.rc == 0
  retries: 30
  delay: 60

- set_fact:
    elb_fqdn: "{{ cmd_result.stdout }}"

- action:
    module: ec2_elb_facts
  register: elb_facts

- set_fact:
    elb_hosted_zone_id: "{{ elb_facts | json_query(query) | join }}"
  vars:
    query:  "elbs[?dns_name=='{{ elb_fqdn }}'].hosted_zone_id"

- block:
    - action:
        module: elb_application_lb_facts
      register: elb_facts
  
    - set_fact:
        elb_hosted_zone_id: "{{ elb_facts | json_query(query) | join }}"
      vars:
        query:  "load_balancers[?dns_name=='{{ elb_fqdn }}'].canonical_hosted_zone_id"

  when: elb_hosted_zone_id | length | int == 0

- debug:
    var: elb_hosted_zone_id

- fail:
  when: elb_hosted_zone_id | length | int == 0

- route53:
    command: create
    zone: "{{ dns_zone }}"
    record: "{{ k8s_namespace }}.{{ dns_zone }}"
    type: A
    value: "{{ elb_fqdn }}"
    overwrite: yes
    alias: True
    alias_hosted_zone_id: "{{ elb_hosted_zone_id }}"

- name: "Waiting for DNS to update on {{ k8s_namespace }}.{{ dns_zone }}"
  shell: >
    dig +short {{ k8s_namespace }}.{{ dns_zone }} | egrep -v "^$"
  args:
    executable: /bin/bash
  register: cmd_result
  until: cmd_result.rc == 0
  retries: 30
  delay: 60

